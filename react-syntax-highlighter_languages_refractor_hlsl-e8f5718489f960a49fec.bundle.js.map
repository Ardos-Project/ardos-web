{"version":3,"file":"react-syntax-highlighter_languages_refractor_hlsl-e8f5718489f960a49fec.bundle.js","mappings":"2GAEAA,EAAO,QAAUC,EACjBA,EAAE,YAAc,IAChBA,EAAE,QAAU,CAAC,EACb,SAASA,EAAEC,EAAO,CAChBA,EAAM,UAAU,EAAIA,EAAM,UAAU,OAAO,QAAS,CAClD,QAAS,CACP,QACE,sEACF,OAAQ,EACV,EACA,OAAQ,CAEN,QAAS,sCACT,OAAQ,EACV,EACA,aAAc,CACZ,QACE,mFACF,WAAY,EACd,EACA,QACE,oVACF,SAAU,wBACV,OACE,oHACF,SAAU,iDACZ,CAAC,EACDA,EAAM,UAAU,aAAa,IAAK,SAAU,CAC1C,KAAM,CAEJ,QAAS,2CACT,OAAQ,EACV,CACF,CAAC,EACDA,EAAM,UAAU,aAAa,IAAK,SAAU,CAC1C,MAAO,CAGL,QACE,4FACF,WAAY,GACZ,OAAQ,GACR,MAAO,WACP,OAAQ,CACN,OAAQ,CACN,CAEE,QAAS,2BACT,WAAY,EACd,EACAA,EAAM,UAAU,EAAE,MACpB,EACA,KAAMA,EAAM,UAAU,EAAE,KACxB,QAASA,EAAM,UAAU,EAAE,QAC3B,aAAc,CACZ,CACE,QAAS,+BACT,WAAY,EACd,EACA,CACE,QAAS,+BACT,WAAY,GACZ,MAAO,UACT,CACF,EAEA,UAAW,CACT,QAAS,gBACT,WAAY,GACZ,MAAO,SACT,EACA,iBAAkB,KAClB,YAAa,kBACb,WAAY,CACV,QAAS,YACT,OAAQA,EAAM,UAAU,CAC1B,CACF,CACF,CACF,CAAC,EACDA,EAAM,UAAU,aAAa,IAAK,WAAY,CAE5C,SACE,4HACJ,CAAC,EACD,OAAOA,EAAM,UAAU,EAAE,OAC3B,C,iBCvFA,IAAIC,EAAa,EAAQ,IAAQ,EACjCH,EAAO,QAAUI,EACjBA,EAAK,YAAc,OACnBA,EAAK,QAAU,CAAC,EAChB,SAASA,EAAKF,EAAO,CACnBA,EAAM,SAASC,CAAU,EACzBD,EAAM,UAAU,KAAOA,EAAM,UAAU,OAAO,IAAK,CAKjD,aAAc,CACZA,EAAM,UAAU,EAAE,YAAY,EAC9B,sgBACF,EACA,QAAS,CAEP,gyBACA,8GACF,EAEA,OACE,gFACF,QAAS,oBACX,CAAC,CACH,C","sources":["webpack://ardos-web/./node_modules/refractor/lang/c.js","webpack://ardos-web/./node_modules/refractor/lang/hlsl.js"],"sourcesContent":["'use strict'\n\nmodule.exports = c\nc.displayName = 'c'\nc.aliases = []\nfunction c(Prism) {\n  Prism.languages.c = Prism.languages.extend('clike', {\n    comment: {\n      pattern:\n        /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n      greedy: true\n    },\n    string: {\n      // https://en.cppreference.com/w/c/language/string_literal\n      pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n      greedy: true\n    },\n    'class-name': {\n      pattern:\n        /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n      lookbehind: true\n    },\n    keyword:\n      /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n    function: /\\b[a-z_]\\w*(?=\\s*\\()/i,\n    number:\n      /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n    operator: />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n  })\n  Prism.languages.insertBefore('c', 'string', {\n    char: {\n      // https://en.cppreference.com/w/c/language/character_constant\n      pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n      greedy: true\n    }\n  })\n  Prism.languages.insertBefore('c', 'string', {\n    macro: {\n      // allow for multiline macro definitions\n      // spaces after the # character compile fine with gcc\n      pattern:\n        /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n      lookbehind: true,\n      greedy: true,\n      alias: 'property',\n      inside: {\n        string: [\n          {\n            // highlight the path of the include statement as a string\n            pattern: /^(#\\s*include\\s*)<[^>]+>/,\n            lookbehind: true\n          },\n          Prism.languages.c['string']\n        ],\n        char: Prism.languages.c['char'],\n        comment: Prism.languages.c['comment'],\n        'macro-name': [\n          {\n            pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n            lookbehind: true\n          },\n          {\n            pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n            lookbehind: true,\n            alias: 'function'\n          }\n        ],\n        // highlight macro directives as keywords\n        directive: {\n          pattern: /^(#\\s*)[a-z]+/,\n          lookbehind: true,\n          alias: 'keyword'\n        },\n        'directive-hash': /^#/,\n        punctuation: /##|\\\\(?=[\\r\\n])/,\n        expression: {\n          pattern: /\\S[\\s\\S]*/,\n          inside: Prism.languages.c\n        }\n      }\n    }\n  })\n  Prism.languages.insertBefore('c', 'function', {\n    // highlight predefined macros as constants\n    constant:\n      /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n  })\n  delete Prism.languages.c['boolean']\n}\n","'use strict'\nvar refractorC = require('./c.js')\nmodule.exports = hlsl\nhlsl.displayName = 'hlsl'\nhlsl.aliases = []\nfunction hlsl(Prism) {\n  Prism.register(refractorC)\n  Prism.languages.hlsl = Prism.languages.extend('c', {\n    // Regarding keywords and class names:\n    // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.\n    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords\n    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words\n    'class-name': [\n      Prism.languages.c['class-name'],\n      /\\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\\b/\n    ],\n    keyword: [\n      // HLSL keyword\n      /\\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\\b/, // scalar, vector, and matrix types\n      /\\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\\b/\n    ],\n    // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers\n    number:\n      /(?:(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?|\\b0x[\\da-fA-F]+)[fFhHlLuU]?\\b/,\n    boolean: /\\b(?:false|true)\\b/\n  })\n}\n"],"names":["module","c","Prism","refractorC","hlsl"],"sourceRoot":""}